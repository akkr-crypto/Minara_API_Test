<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Market Audio Report</title>
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; text-align: center; padding: 40px; background: #f0f4f8; color: #333; }
        .container { max-width: 700px; margin: 0 auto; background: white; padding: 40px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        
        /* 入力エリアのデザイン */
        .input-group { margin-bottom: 20px; text-align: left; }
        .input-group label { display: block; font-size: 14px; font-weight: bold; color: #555; margin-bottom: 5px; }
        input[type="text"], input[type="password"], textarea, select { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; box-sizing: border-box; font-size: 16px; }
        textarea { height: 80px; resize: vertical; }

        /* スライダーのデザイン */
        .slider-container { display: flex; align-items: center; gap: 10px; }
        input[type="range"] { flex-grow: 1; }
        
        /* ボタン */
        button { width: 100%; padding: 12px; font-size: 18px; cursor: pointer; background: #3ea8ff; color: white; border: none; border-radius: 50px; transition: background 0.3s; font-weight: bold; margin-top: 10px; }
        button:hover { background: #2c88d9; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        #stop-btn { background: #ff4d4d; }
        #stop-btn:hover { background: #d93025; }

        /* 結果表示エリア */
        #response-container { margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px; display: none; text-align: left; border: 1px solid #eee; max-height: 400px; overflow-y: auto; scroll-behavior: smooth; }
        .response-line { margin-bottom: 8px; line-height: 1.6; padding: 4px; border-radius: 4px; }
        /* 読み上げ中のハイライト */
        .speaking-line { background-color: #d1e7ff; font-weight: bold; }
        
        #status { margin-top: 15px; font-size: 14px; color: #666; min-height: 20px; }
    </style>
</head>
<body>

    <div class="container">
        <h2>Market Audio Report Generator</h2>

        <div class="input-group">
            <label>API Key</label>
            <input type="password" id="api-key-input" placeholder="Minara API Key (xn-...)">
        </div>

        <div style="display: flex; gap: 20px; margin-bottom: 20px;">
            <div class="input-group" style="flex: 1;">
                <label>キャラクター</label>
                <select id="speaker-select">
                    <option value="3">読み込み中...</option>
                </select>
            </div>
            <div class="input-group" style="flex: 1;">
                <label>話速: <span id="speed-display">1.2</span>x</label>
                <div class="slider-container">
                    <input type="range" id="speed-slider" min="0.5" max="2.0" step="0.1" value="1.2" oninput="updateSpeedDisplay()">
                </div>
            </div>
        </div>

        <div class="input-group">
            <label>レポート対象 / プロンプト</label>
            <textarea id="question" placeholder="例: 今日の暗号資産市場の動向を要約して"></textarea>
        </div>

        <div style="display: flex; gap: 10px;">
            <button id="btn" onclick="executeReportGeneration()">レポート生成・読み上げ</button>
            <button id="stop-btn" onclick="stopPlayback()" disabled>停止</button>
        </div>
        <div id="status"></div>
        <div id="response-container"></div>
    </div>

    <script>
        const API_ENDPOINT = "/api/generate_report";
        const VOICEVOX_URL = "http://127.0.0.1:50021"; 
        const PAUSE_TIME = 500;
        
        let currentAudio = null;
        let currentResolve = null;
        let shouldStop = false;
        let speechQueue = [];
        let isSpeaking = false;

        window.onload = async function() {
            updateSpeedDisplay();
            await loadSpeakers();
        };

        function updateSpeedDisplay() {
            const val = document.getElementById("speed-slider").value;
            document.getElementById("speed-display").innerText = val;
            if (currentAudio) {
                currentAudio.playbackRate = Number(val);
            }
        }

        async function loadSpeakers() {
            const select = document.getElementById("speaker-select");
            try {
                const res = await fetch(`${VOICEVOX_URL}/speakers`);
                if (!res.ok) throw new Error("VOICEVOX未接続");
                const speakers = await res.json();
                
                select.innerHTML = ""; 
                speakers.forEach(sp => {
                    sp.styles.forEach(style => {
                        const option = document.createElement("option");
                        option.value = style.id;
                        option.text = `${sp.name} (${style.name})`;
                        if (style.id === 3) option.selected = true;
                        select.appendChild(option);
                    });
                });
            } catch (e) {
                console.error(e);
                select.innerHTML = '<option value="3">ずんだもん (ノーマル) - 接続失敗</option>';
                document.getElementById("status").innerText = "VOICEVOXへの接続に失敗しました。アプリケーションが起動しているか確認してください。";
            }
        }

        function stopPlayback() {
            shouldStop = true;
            speechQueue = [];
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            if (currentResolve) {
                currentResolve();
                currentResolve = null;
            }
            document.getElementById("status").innerText = "再生を停止しました";
        }

        async function processSpeechQueue(speakerId) {
            if (isSpeaking) return;
            isSpeaking = true;
            
            while (speechQueue.length > 0) {
                if (shouldStop) {
                    speechQueue = [];
                    break;
                }
                const item = speechQueue.shift();
                if (item.element) item.element.classList.add("speaking-line");
                await playVoiceAndWait(item.text, speakerId);
                if (item.element) item.element.classList.remove("speaking-line");
                if (!shouldStop && speechQueue.length > 0) await wait(PAUSE_TIME);
            }
            isSpeaking = false;
        }

        async function executeReportGeneration() {
            const text = document.getElementById("question").value;
            const apiKey = document.getElementById("api-key-input").value;
            const speakerId = document.getElementById("speaker-select").value;

            if(!apiKey) return alert("API Keyを入力してください");
            if(!text) return;

            const btn = document.getElementById("btn");
            const stopBtn = document.getElementById("stop-btn");
            const status = document.getElementById("status");
            const resContainer = document.getElementById("response-container");

            btn.disabled = true;
            stopBtn.disabled = false;
            shouldStop = false;
            speechQueue = [];
            status.innerText = "レポート生成中...";
            resContainer.style.display = "none";
            resContainer.innerHTML = "";

            try {
                const res = await fetch(API_ENDPOINT, {
                    method: "POST",
                    headers: { "Content-Type": "application/json", "X-Minara-Key": apiKey },
                    body: JSON.stringify({ text: text })
                });

                if(!res.ok) {
                    throw new Error(`Server Error: ${res.status}`);
                }

                // ストリーミング受信とUI更新
                resContainer.style.display = "block";
                status.innerText = "読み上げ開始...";

                const reader = res.body.getReader();
                const decoder = new TextDecoder();
                let buffer = "";
                let sentenceBuffer = "";
                let currentP = null;

                while (true) {
                    if (shouldStop) break;
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    let lines = buffer.split("\n");
                    buffer = lines.pop(); 

                    for (let line of lines) {
                        if (!line.trim()) continue;

                        let contentText = line;
                        try {
                            const json = JSON.parse(line);
                            if (json.content) contentText = json.content;
                        } catch (e) {
                            // ignore json parse error
                        }

                        if (!currentP) {
                            currentP = document.createElement('p');
                            currentP.className = "response-line";
                            resContainer.appendChild(currentP);
                        }
                        currentP.innerText += contentText;
                        currentP.scrollIntoView({ behavior: "smooth", block: "end" });

                        sentenceBuffer += contentText;

                        while (true) {
                            const match = sentenceBuffer.match(/[。！？\n]/);
                            if (!match) break;

                            const index = match.index;
                            const sentence = sentenceBuffer.substring(0, index + 1);
                            sentenceBuffer = sentenceBuffer.substring(index + 1);

                            const cleanLine = sanitizeForSpeech(sentence);
                            if (cleanLine.length > 0) {
                                speechQueue.push({ text: cleanLine, element: currentP });
                                processSpeechQueue(speakerId);
                            }
                            
                            if (sentence.includes("\n")) {
                                currentP = null;
                            }
                        }
                    }
                }

                if (sentenceBuffer.length > 0) {
                    const cleanLine = sanitizeForSpeech(sentenceBuffer);
                    if (cleanLine.length > 0) {
                        speechQueue.push({ text: cleanLine, element: currentP });
                        processSpeechQueue(speakerId);
                    }
                }

                if (!shouldStop) status.innerText = "完了";

            } catch (e) {
                status.innerText = "エラー: " + e.message;
            } finally {
                btn.disabled = false;
                stopBtn.disabled = true;
            }
        }

        async function playVoiceAndWait(text, speakerId) {
            if (shouldStop) return;
            const q = await fetch(`${VOICEVOX_URL}/audio_query?speaker=${speakerId}&text=${encodeURIComponent(text)}`, { method: "POST" });
            const queryData = await q.json();
            
            if (shouldStop) return;

            const s = await fetch(`${VOICEVOX_URL}/synthesis?speaker=${speakerId}`, {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify(queryData)
            });
            const b = await s.blob();
            
            if (shouldStop) return;

            return new Promise((resolve) => {
                const audio = new Audio(URL.createObjectURL(b));
                audio.playbackRate = Number(document.getElementById("speed-slider").value);
                currentAudio = audio;
                currentResolve = resolve;
                audio.onended = () => {
                    currentAudio = null;
                    currentResolve = null;
                    resolve();
                };
                audio.play();
            });
        }

        function sanitizeForSpeech(text) {
            let t = text.replace(/BTC/g, "ビットコイン").replace(/ETH/g, "イーサリアム").replace(/SOL/g, "ソラナ");
            t = t.replace(/(\d+)\/(\d+)/g, "$1スラッシュ$2");
            t = t.replace(/[*#`]/g, "").replace(/https?:\/\/\S+/g, "URLリンク");
            t = t.replace(/(\d{1,3}),(\d{3})/g, "$1$2").replace(/(\d)\.(\d)/g, "$1点$2");
            t = t.replace(/[^\w\s\u3000-\u30Fe\u4e00-\u9fa5、。点スラッシュ]/g, "");
            return t.trim().length === 0 ? "" : t.substring(0, 200);
        }

        function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
    </script>
</body>
</html>